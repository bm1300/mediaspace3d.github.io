<!DOCTYPE html>
<html lang="zh-CN">

<head>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/omggif/1.0.1/omggif.min.js"></script>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>æœ¬åœ°åª’ä½“ç›¸å†Œ3Dè™šæ‹Ÿå±•ç¤ºç©ºé—´</title>
	<link rel="icon" type="image/png" href="favicon.png" sizes="32x32">
	<style>
		/* å¼€å±ä»‹ç»æ ·å¼ */
		#splash-screen
		{
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: linear-gradient(135deg, #0a0b14 0%, #1a1d2b 100%);
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			z-index: 9999;
			color: white;
			font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
			transition: opacity 0.8s ease, transform 0.8s ease;
			padding: 20px;
		}

			#splash-screen.hidden
			{
				opacity: 0;
				pointer-events: none;
				transform: translateY(-20px);
			}

		.splash-content
		{
			max-width: 800px;
			text-align: center;
			padding: 40px;
			background: rgba(255, 255, 255, 0.08);
			backdrop-filter: blur(20px);
			border-radius: 24px;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
		}

		.splash-logo
		{
			font-size: 48px;
			font-weight: 700;
			margin-bottom: 30px;
			background: linear-gradient(90deg, #6a89ff, #4d8aff);
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
			background-clip: text;
			letter-spacing: 1px;
		}

		.splash-title
		{
			font-size: 36px;
			font-weight: 600;
			margin-bottom: 20px;
			color: rgba(255, 255, 255, 0.95);
		}

		.splash-subtitle
		{
			font-size: 18px;
			color: rgba(255, 255, 255, 0.7);
			margin-bottom: 40px;
			line-height: 1.6;
			max-width: 600px;
		}

		.splash-features
		{
			display: grid;
			grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
			gap: 20px;
			margin: 40px 0;
		}

		.feature-card
		{
			background: rgba(255, 255, 255, 0.05);
			border-radius: 16px;
			padding: 24px;
			border: 1px solid rgba(255, 255, 255, 0.08);
			transition: all 0.3s ease;
		}

			.feature-card:hover
			{
				transform: translateY(-5px);
				background: rgba(255, 255, 255, 0.08);
				border-color: rgba(255, 255, 255, 0.15);
			}

		.feature-icon
		{
			font-size: 32px;
			margin-bottom: 15px;
		}

		.feature-title
		{
			font-size: 16px;
			font-weight: 600;
			margin-bottom: 10px;
			color: rgba(255, 255, 255, 0.9);
		}

		.feature-desc
		{
			font-size: 14px;
			color: rgba(255, 255, 255, 0.6);
			line-height: 1.5;
		}

		.splash-controls
		{
			margin-top: 40px;
		}

		.start-button
		{
			background: linear-gradient(135deg, #4d8aff 0%, #6a89ff 100%);
			color: white;
			border: none;
			padding: 16px 48px;
			border-radius: 12px;
			font-size: 18px;
			font-weight: 600;
			cursor: pointer;
			transition: all 0.3s ease;
			box-shadow: 0 8px 25px rgba(77, 138, 255, 0.3);
		}

			.start-button:hover
			{
				transform: translateY(-3px);
				box-shadow: 0 12px 35px rgba(77, 138, 255, 0.4);
			}

			.start-button:active
			{
				transform: translateY(0);
			}

		.quick-start
		{
			color: rgba(255, 255, 255, 0.5);
			font-size: 14px;
			margin-top: 20px;
			text-align: center;
			line-height: 1.6;
		}
		/* åŸºç¡€æ ·å¼ */
		*
		{
			box-sizing: border-box;
			margin: 0;
			padding: 0;
		}

		body
		{
			overflow: hidden;
			font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
			background: linear-gradient(135deg, #1a1d2b 0%, #0f111a 100%);
			color: #e6e6e6;
			height: 100vh;
			position: relative;
		}

		#canvas-container
		{
			position: absolute;
			width: 100%;
			height: 100%;
		}

		/* UI é¢æ¿æ ·å¼ - ç®€çº¦ç°ä»£ */
		#ui
		{
			position: absolute;
			top: 20px;
			left: 20px;
			z-index: 100;
			background: rgba(255, 255, 255, 0.08);
			backdrop-filter: blur(20px);
			padding: 18px;
			border-radius: 16px;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25);
			transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
			max-width: 320px;
		}

			#ui.hidden
			{
				opacity: 0;
				pointer-events: none;
				transform: translateY(-10px);
			}

		/* æŒ‰é’®æ ·å¼ - ç®€çº¦ç°ä»£ */
		button
		{
			background: rgba(255, 255, 255, 0.1);
			color: rgba(255, 255, 255, 0.9);
			border: 1px solid rgba(255, 255, 255, 0.15);
			padding: 12px 16px;
			margin: 6px;
			border-radius: 10px;
			cursor: pointer;
			font-weight: 500;
			font-size: 14px;
			transition: all 0.2s ease;
			backdrop-filter: blur(10px);
			width: calc(50% - 12px);
			display: inline-block;
			text-align: center;
		}

			button:hover
			{
				background: rgba(255, 255, 255, 0.15);
				transform: translateY(-2px);
				box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
			}

			button:active
			{
				transform: translateY(0);
			}

		#file-input
		{
			display: none;
		}

		/* å‡†æ˜Ÿæ ·å¼ */
		#crosshair
		{
			position: absolute;
			top: 50%;
			left: 50%;
			width: 20px;
			height: 20px;
			transform: translate(-50%, -50%);
			transition: opacity 0.3s ease;
			z-index: 50;
		}

			#crosshair::before,
			#crosshair::after
			{
				content: '';
				position: absolute;
				background-color: rgba(255, 255, 255, 0.8);
				border-radius: 1px;
			}

			#crosshair::before
			{
				width: 2px;
				height: 100%;
				left: 50%;
				transform: translateX(-50%);
			}

			#crosshair::after
			{
				width: 100%;
				height: 2px;
				top: 50%;
				transform: translateY(-50%);
			}

			#crosshair.hidden
			{
				opacity: 0;
			}

		/* è¯´æ˜é¢æ¿ */
		#instructions
		{
			position: absolute;
			bottom: 20px;
			left: 20px;
			background: rgba(255, 255, 255, 0.08);
			backdrop-filter: blur(20px);
			padding: 14px 18px;
			border-radius: 16px;
			font-size: 13px;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25);
			transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
			max-width: 320px;
			line-height: 1.6;
		}

			#instructions.hidden
			{
				opacity: 0;
				transform: translateY(10px);
			}

		/* è§†é¢‘æ§åˆ¶é¢æ¿ */
		#video-controls
		{
			position: absolute;
			bottom: 20px;
			right: 20px;
			background: rgba(255, 255, 255, 0.08);
			backdrop-filter: blur(20px);
			padding: 18px;
			border-radius: 16px;
			color: white;
			z-index: 100;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25);
			transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
			min-width: 280px;
		}

			#video-controls.hidden
			{
				opacity: 0;
				pointer-events: none;
				transform: translateY(10px);
			}

		.control-row
		{
			display: flex;
			align-items: center;
			margin: 10px 0;
		}

		.control-label
		{
			width: 60px;
			font-size: 13px;
			font-weight: 500;
			color: rgba(255, 255, 255, 0.7);
		}

		.slider-container
		{
			flex: 1;
			position: relative;
			height: 20px;
		}

		.slider
		{
			width: 100%;
			height: 4px;
			background: rgba(255, 255, 255, 0.15);
			border-radius: 2px;
			position: relative;
			cursor: pointer;
		}

		.slider-progress
		{
			position: absolute;
			height: 100%;
			background: rgba(255, 255, 255, 0.8);
			border-radius: 2px;
		}

		.slider-handle
		{
			position: absolute;
			width: 14px;
			height: 14px;
			background: white;
			border-radius: 50%;
			top: 50%;
			transform: translate(-50%, -50%);
			cursor: pointer;
			box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
			transition: transform 0.1s ease;
		}

			.slider-handle:hover
			{
				transform: translate(-50%, -50%) scale(1.2);
			}

		.control-button
		{
			background: rgba(255, 255, 255, 0.1);
			border: 1px solid rgba(255, 255, 255, 0.15);
			color: white;
			padding: 8px 14px;
			margin: 0 6px;
			border-radius: 8px;
			cursor: pointer;
			font-size: 12px;
			transition: all 0.2s ease;
		}

			.control-button:hover
			{
				background: rgba(255, 255, 255, 0.15);
			}

		/* åŠ è½½ç•Œé¢ */
		#loading-overlay
		{
			position: absolute;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(15, 17, 26, 0.95);
			display: flex;
			flex-direction: column;
			justify-content: center;
			align-items: center;
			z-index: 200;
			color: white;
			transition: opacity 0.5s ease;
		}

			#loading-overlay.hidden
			{
				opacity: 0;
				pointer-events: none;
			}

		#loading-text
		{
			font-size: 18px;
			margin-bottom: 20px;
			font-weight: 500;
			color: rgba(255, 255, 255, 0.9);
		}

		#loading-progress
		{
			width: 300px;
			height: 4px;
			background-color: rgba(255, 255, 255, 0.1);
			border-radius: 2px;
			margin-top: 20px;
			overflow: hidden;
		}

		#loading-bar
		{
			height: 100%;
			background: rgba(255, 255, 255, 0.8);
			width: 0%;
			transition: width 0.3s ease;
			border-radius: 2px;
		}

		/* æ€§èƒ½ç»Ÿè®¡ */
		#performance-stats
		{
			position: absolute;
			top: 20px;
			right: 20px;
			background: rgba(255, 255, 255, 0.08);
			backdrop-filter: blur(20px);
			color: white;
			padding: 12px 16px;
			border-radius: 16px;
			font-size: 12px;
			z-index: 100;
			border: 1px solid rgba(255, 255, 255, 0.1);
			box-shadow: 0 12px 40px rgba(0, 0, 0, 0.25);
			line-height: 1.5;
		}

			#performance-stats.hidden
			{
				opacity: 0;
				pointer-events: none;
				transform: translateY(-10px);
			}

		.stat-value
		{
			color: rgba(255, 255, 255, 0.9);
			font-weight: 600;
		}

		/* æ ‡é¢˜æ ·å¼ */
		.panel-title
		{
			font-size: 14px;
			font-weight: 600;
			margin-bottom: 12px;
			color: rgba(255, 255, 255, 0.9);
			display: flex;
			align-items: center;
		}

			.panel-title::before
			{
				content: '';
				display: inline-block;
				width: 4px;
				height: 16px;
				background: rgba(255, 255, 255, 0.8);
				margin-right: 10px;
				border-radius: 2px;
			}

		/* æŒ‰é’®ç»„å¸ƒå±€ */
		.button-group
		{
			display: flex;
			flex-wrap: wrap;
			justify-content: space-between;
		}

		/* å“åº”å¼è°ƒæ•´ */
		@media (max-width: 768px)
		{
			#ui, #instructions, #video-controls, #performance-stats
			{
				padding: 14px;
				font-size: 12px;
				max-width: 280px;
			}

			button
			{
				padding: 10px 12px;
				font-size: 12px;
			}

			#instructions
			{
				max-width: 250px;
			}
		}

		/* éšè—åˆ‡æ¢åœ°é¢æŒ‰é’® */
		#toggle-ground
		{
			display: none !important;
		}

		/* éšè—åˆ‡æ¢æ˜Ÿç©ºæŒ‰é’® */
		#toggle-stars
		{
			display: none !important;
		}

		/* éšè—æ€§èƒ½æ¨¡å¼æŒ‰é’® */
		#performance-toggle
		{
			display: none !important;
		}
	</style>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
</head>

<body>
    <div id="splash-screen">
        <div class="splash-content">
			<h1 class="splash-title">æœ¬åœ°åª’ä½“ç›¸å†Œ3Dè™šæ‹Ÿå±•ç¤ºç©ºé—´</h1>
            <p class="splash-subtitle">ä¸€ä¸ªæ²‰æµ¸å¼çš„æœ¬åœ°åª’ä½“æ–‡ä»¶æµè§ˆä½“éªŒã€‚å°†æ‚¨çš„å›¾ç‰‡å’Œè§†é¢‘æ–‡ä»¶æ”¾ç½®åœ¨è™šæ‹Ÿç©ºé—´ä¸­ï¼Œä»¥ç¬¬ä¸€äººç§°è§†è§’è‡ªç”±æ¢ç´¢ã€‚</p>

            <div class="splash-features">
                <div class="feature-card">
                    <div class="feature-icon">ğŸ“</div>
                    <h3 class="feature-title">æ‰¹é‡å¯¼å…¥</h3>
                    <p class="feature-desc">æ”¯æŒå¯¼å…¥æ•´ä¸ªæ–‡ä»¶å¤¹çš„å›¾ç‰‡å’Œè§†é¢‘æ–‡ä»¶</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">ğŸ®</div>
                    <h3 class="feature-title">ç¬¬ä¸€äººç§°æ¢ç´¢</h3>
                    <p class="feature-desc">ä½¿ç”¨WASDåœ¨è™šæ‹Ÿç©ºé—´ä¸­è‡ªç”±è¡Œèµ°ï¼Œæ¢ç´¢ä½ çš„åª’ä½“</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">ğŸ¬</div>
                    <h3 class="feature-title">äº¤äº’å¼æ’­æ”¾</h3>
                    <p class="feature-desc">é è¿‘åª’ä½“æ–‡ä»¶å³å¯ç‚¹å‡»æ’­æ”¾ï¼Œæ”¯æŒè§†é¢‘æ§åˆ¶</p>
                </div>
                <div class="feature-card">
                    <div class="feature-icon">ğŸ”</div>
                    <h3 class="feature-title">éšç§ä¿éšœ</h3>
					<p class="feature-desc">åª’ä½“æ–‡ä»¶ä»…åœ¨æµè§ˆå™¨æœ¬åœ°å¤„ç†ï¼Œä¸ä¸Šä¼ è‡³ä»»ä½•æœåŠ¡å™¨</p>
                </div>
            </div>

            <div class="splash-controls">
                <button id="start-button" class="start-button">å¼€å§‹ä½“éªŒ</button>
				<div class="quick-start">
					<p>æ“ä½œæŒ‡å—ï¼šWASDç§»åŠ¨ï¼ŒShiftè·‘æ­¥ï¼ŒESC/å³é”®è§£é”é¼ æ ‡</p>
					<p>è§†é¢‘äº¤äº’ï¼šé è¿‘ç‚¹å‡»æ’­æ”¾ï¼ŒTabéšè—UIï¼ŒF11å…¨å±</p>
					<p>=================================</p>
					<p>BM1300 | 249390193@qq.com</p>
				</div>
            </div>
        </div>
    </div>
    <div id="canvas-container"></div>

    <div id="ui">
        <div class="panel-title">åª’ä½“æ§åˆ¶</div>
		<div class="button-group">
			<button id="import-folder">å¯¼å…¥æ–‡ä»¶å¤¹</button>
			<button id="import-files">å¯¼å…¥æ–‡ä»¶</button>
			<button id="remove-all">æ¸…ç©º</button>
			<button id="reset-position">äººç‰©å¤ä½</button>
			<button id="performance-toggle">æ€§èƒ½æ¨¡å¼</button>
			<button id="toggle-ground">åˆ‡æ¢åœ°é¢</button>
			<button id="toggle-stars">åˆ‡æ¢æ˜Ÿç©º</button>
		</div>
    </div>

    <div id="performance-stats">
        <div>
            åª’ä½“:
            <span class="stat-value" id="media-count">0</span>
        </div>
        <div>
            å¯è§:
            <span class="stat-value" id="visible-count">0</span>
        </div>
        <div>
            å†…å­˜:
            <span class="stat-value" id="memory-usage">0 MB</span>
        </div>
        <div>
            FPS:
            <span class="stat-value" id="fps-counter">0</span>
        </div>
    </div>

    <div id="crosshair"></div>

    <div id="instructions">
        <div class="panel-title">æ“ä½œæŒ‡å—</div>
        ç§»åŠ¨: WASD | è·‘æ­¥: Shift | è§£é”é¼ æ ‡: ESC/å³å‡»
        <br>
        è§†é¢‘æ’­æ”¾: é è¿‘ç‚¹å‡» | å·¦/å³æ–¹å‘é”®å¿«é€€/å¿«è¿›5ç§’
        <br>
        éšè—UI: Tab | å…¨å±: F11
    </div>

    <div id="video-controls" class="hidden">
        <div class="panel-title">è§†é¢‘æ§åˆ¶</div>
        <div class="control-row">
            <div class="control-label">è¿›åº¦:</div>
            <div class="slider-container">
                <div class="slider" id="progress-slider">
                    <div class="slider-progress" id="progress-bar"></div>
                    <div class="slider-handle" id="progress-handle"></div>
                </div>
            </div>
        </div>
        <div class="control-row">
            <div class="control-label">éŸ³é‡:</div>
            <div class="slider-container">
                <div class="slider" id="volume-slider">
                    <div class="slider-progress" id="volume-bar"></div>
                    <div class="slider-handle" id="volume-handle"></div>
                </div>
            </div>
        </div>
        <div class="control-row" style="justify-content: center; margin-top: 12px;">
            <button class="control-button" id="play-pause-btn">æš‚åœ</button>
            <button class="control-button" id="mute-btn">é™éŸ³</button>
        </div>
    </div>

    <div id="loading-overlay" class="hidden">
        <div id="loading-text">æ­£åœ¨åŠ è½½åª’ä½“æ–‡ä»¶...</div>
        <div id="loading-progress">
            <div id="loading-bar"></div>
        </div>
    </div>

    <input type="file" id="file-input" multiple webkitdirectory>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>
	<script>
		// ä¸»åº”ç”¨ç¨‹åºç±» - ç®€çº¦ç°ä»£ç‰ˆ
		class VirtualMediaSpace {
			constructor() {
				this.scene = null;
				this.camera = null;
				this.renderer = null;
				this.controls = null;

				this.mediaObjects = []; // æ‰€æœ‰åª’ä½“å¯¹è±¡
				this.visibleMedia = []; // å½“å‰å¯è§çš„åª’ä½“å¯¹è±¡
				this.mediaPool = []; // åª’ä½“æ± ï¼Œç”¨äºå¤ç”¨
				this.currentlyPlaying = null;

				this.isImmersive = false;
				this.lastMoveTime = Date.now();
				this.crosshairVisible = true;
				this.isPointerLocked = false;

				this.videoControlsVisible = false;

				// æ€§èƒ½ä¼˜åŒ–ç›¸å…³å±æ€§
				this.performanceMode = false;
				this.loadingQueue = [];
				this.isLoading = false;
				this.loadedCount = 0;
				this.totalToLoad = 0;
				this.frameCount = 0;
				this.lastFpsUpdate = 0;
				this.fps = 0;

				// åŠ¨æ€åˆ†å¸ƒç›¸å…³å±æ€§ - æ— åºåŠ è½½æ–¹å¼
				this.viewDistance = 60; // å¯è§†è·ç¦»
				this.spawnDistance = 60; // ç”Ÿæˆè·ç¦»ï¼ˆæœ€è¿œï¼‰
				this.minDistance = 11; // æœ€è¿‘ç”Ÿæˆè·ç¦»
				this.minSpacing = 11; // æœ€å°é—´è·ï¼ˆç±³ï¼‰
				this.maxVisibleMedia = 30; // æœ€å¤§å¯è§åª’ä½“æ•°é‡
				this.gridSize = this.minSpacing; // ç½‘æ ¼å¤§å°
				this.occupiedGrids = new Set(); // å·²å ç”¨çš„ç½‘æ ¼ä½ç½®
				this.lastSpawnCheck = 0;
				this.spawnInterval = 500; // ç”Ÿæˆæ£€æŸ¥é—´éš”ï¼ˆæ¯«ç§’ï¼‰
				this.donationQR = null; // æ‰“èµäºŒç»´ç å¯¹è±¡

				// å†…å­˜ç®¡ç†
				this.maxMediaObjects = 2000; // æœ€å¤§åª’ä½“å¯¹è±¡æ•°é‡
				this.unloadDistance = 60; // å¸è½½è·ç¦»ï¼ˆç±³ï¼‰

				// æ˜Ÿç©ºç²’å­
				this.stars = null;
				this.twinklingStars = null;
				this.starLayers = [];
				this.starfieldEnabled = true;
				this.time = 0; // ç”¨äºæ˜Ÿç©ºåŠ¨ç”»çš„æ—¶é—´å˜é‡

				// åœ°é¢ç›¸å…³
				this.groundEnabled = true;
				this.groundType = 'grid'; // 'grid' æˆ– 'marble'
				this.groundObjects = [];
				this.groundReflection = null;

				// è§†é¢‘æ§åˆ¶ç›¸å…³
				this.currentlyPlaying = null;
				this.videoControlsVisible = false;

				this.init();
				this.setupEventListeners();
				this.animate();
				this.startPerformanceMonitoring();

				// é‡ç”Ÿç‚¹æ’é™¤åŠå¾„
				this.spawnExclusionRadius = 15; // é‡ç”Ÿç‚¹æ’é™¤åŠå¾„ï¼ˆç±³ï¼‰ï¼Œæ¯”11ç±³å¤§ä¸€äº›
				this.spawnPoint = new THREE.Vector3(0, 1.7, 0); // é‡ç”Ÿç‚¹åæ ‡
			}

		// è§†é¢‘å¿«è¿›å¿«é€€æ–¹æ³•
		seekVideo(seconds) {
		if (this.currentlyPlaying &&
		this.currentlyPlaying.element &&
		this.currentlyPlaying.type === 'video') {

		const video = this.currentlyPlaying.element;

		// è®¡ç®—æ–°çš„æ—¶é—´
		let newTime = video.currentTime + seconds;

		// ç¡®ä¿æ—¶é—´åœ¨æœ‰æ•ˆèŒƒå›´å†…
		newTime = Math.max(0, Math.min(newTime, video.duration));

		// è®¾ç½®æ–°çš„æ—¶é—´
		video.currentTime = newTime;

		// æ›´æ–°è§†é¢‘æ§åˆ¶UI
		this.updateVideoControlsUI();

		// æ˜¾ç¤ºæ“ä½œæç¤ºï¼ˆå¯é€‰ï¼‰
		this.showSeekFeedback(seconds);

		console.log(`è§†é¢‘ ${seconds > 0 ? 'å¿«è¿›' : 'å¿«é€€'} ${Math.abs(seconds)} ç§’ï¼Œæ–°æ—¶é—´: ${newTime.toFixed(1)}/${video.duration.toFixed(1)}`);
		}
		}

		init() {
		// åˆ›å»ºåœºæ™¯
		this.scene = new THREE.Scene();
		this.scene.background = new THREE.Color(0x0a0b14);

		// åˆ›å»ºç›¸æœº
		this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
		this.camera.position.y = 1.7; // è®¾ç½®äººç‰©é«˜åº¦ä¸º1.7ç±³

		// åˆ›å»ºæ¸²æŸ“å™¨
		this.renderer = new THREE.WebGLRenderer({
		antialias: true,
		powerPreference: "high-performance"
		});
		this.renderer.setSize(window.innerWidth, window.innerHeight);
		this.renderer.shadowMap.enabled = false; // ç®€çº¦é£æ ¼ä¸éœ€è¦é˜´å½±
		document.getElementById('canvas-container').appendChild(this.renderer.domElement);

		// æ·»åŠ å¾®å¼±çš„å…¨å±€ç¯å¢ƒå…‰
		const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
		this.scene.add(ambientLight);

		// æ·»åŠ ä¸€ç‚¹æ–¹å‘å…‰ï¼Œä½¿åœºæ™¯æ›´æœ‰å±‚æ¬¡æ„Ÿ
		const directionalLight = new THREE.DirectionalLight(0xffffff, 0.2);
		directionalLight.position.set(50, 100, 50);
		this.scene.add(directionalLight);

		// åˆ›å»ºæ”¹è¿›çš„æ˜Ÿç©ºèƒŒæ™¯
		this.createImprovedStarfield();

		// åˆ›å»ºæ”¹è¿›çš„åœ°é¢
		this.createEnhancedGround();

		// åˆ›å»ºæ‰“èµäºŒç»´ç 
		this.createDonationQRCode();

		// åˆå§‹åŒ–ç¬¬ä¸€äººç§°æ§åˆ¶å™¨
		this.setupFirstPersonControls();
		}

		// åˆ›å»ºæ”¹è¿›çš„æ˜Ÿç©º
		createImprovedStarfield() {
		// æ¸…ç©ºä¹‹å‰çš„æ˜Ÿç©º
		if (this.starLayers.length > 0) {
		this.starLayers.forEach(layer => this.scene.remove(layer.mesh));
		this.starLayers = [];
		}

		if (!this.starfieldEnabled) return;

		// åˆ›å»ºä¸‰å±‚æ˜Ÿç©ºï¼Œä¸åŒå¤§å°å’Œäº®åº¦ï¼Œæ¨¡æ‹Ÿæ·±åº¦
		const layerConfigs = [
		{ count: 4000, size: 0.6, opacity: 0.15, radius: 600, speed: 0.00005 }, // è¿œå¤„å°æ˜Ÿæ˜Ÿ
		{ count: 3000, size: 1.0, opacity: 0.4, radius: 400, speed: 0.00003 }, // ä¸­è·ç¦»æ˜Ÿæ˜Ÿ
		{ count: 1500, size: 1.5, opacity: 0.8, radius: 250, speed: 0.00001 }  // è¿‘å¤„äº®æ˜Ÿæ˜Ÿ
		];

		layerConfigs.forEach((config, layerIndex) => {
		const starGeometry = new THREE.BufferGeometry();
		const starPositions = new Float32Array(config.count * 3);
		const starColors = new Float32Array(config.count * 3);
		const starSizes = new Float32Array(config.count);
		const starAlphas = new Float32Array(config.count);
		const starSpeeds = new Float32Array(config.count);

		for (let i = 0; i < config.count * 3; i += 3) {
		// çƒçŠ¶åˆ†å¸ƒ
		const radius = config.radius + (Math.random() * 100);
		const theta = Math.random() * Math.PI * 2;
		const phi = Math.acos(2 * Math.random() - 1);

		starPositions[i] = radius * Math.sin(phi) * Math.cos(theta);
		starPositions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
		starPositions[i + 2] = radius * Math.cos(phi);

		// éšæœºé¢œè‰²ï¼ˆå†·è‰²è°ƒï¼‰
		const color = new THREE.Color();
		const hue = 0.6 + (Math.random() * 0.1); // è“è‰²è°ƒ
		const saturation = 0.2 + (Math.random() * 0.2);
		const lightness = 0.7 + (Math.random() * 0.3);
		color.setHSL(hue, saturation, lightness);

		starColors[i] = color.r;
		starColors[i + 1] = color.g;
		starColors[i + 2] = color.b;

		// éšæœºå¤§å°
		starSizes[i / 3] = config.size * (0.5 + Math.random() * 0.8);

		// éšæœºé€æ˜åº¦
		starAlphas[i / 3] = config.opacity * (0.7 + Math.random() * 0.6);

		// éšæœºé—ªçƒé€Ÿåº¦
		starSpeeds[i / 3] = 1 + Math.random() * 3;
		}

		starGeometry.setAttribute('position', new THREE.BufferAttribute(starPositions, 3));
		starGeometry.setAttribute('color', new THREE.BufferAttribute(starColors, 3));
		starGeometry.setAttribute('size', new THREE.BufferAttribute(starSizes, 1));
		starGeometry.setAttribute('alpha', new THREE.BufferAttribute(starAlphas, 1));
		starGeometry.setAttribute('speed', new THREE.BufferAttribute(starSpeeds, 1));

		// åˆ›å»ºæ˜Ÿæ˜Ÿæè´¨
		const starMaterial = new THREE.PointsMaterial({
		vertexColors: true,
		size: config.size,
		sizeAttenuation: true,
		transparent: true,
		opacity: 1.0,
		blending: THREE.AdditiveBlending,
		depthWrite: false
		});

		const starLayer = new THREE.Points(starGeometry, starMaterial);
		starLayer.userData = {
		speed: config.speed,
		timeOffset: Math.random() * 1000
		};

		this.scene.add(starLayer);
		this.starLayers.push({
		mesh: starLayer,
		material: starMaterial,
		speed: config.speed,
		geometry: starGeometry,
		alphas: starAlphas,
		speeds: starSpeeds
		});
		});
		}

		// æ›´æ–°æ˜Ÿç©ºåŠ¨ç”»
		updateStarfield() {
		if (!this.starfieldEnabled || this.starLayers.length === 0) return;

		this.time += 0.016; // çº¦60fpsçš„æ—¶é—´å¢é‡

		this.starLayers.forEach(layer => {
		// è½»å¾®æ—‹è½¬ï¼Œæ¨¡æ‹Ÿæ˜Ÿç©ºç§»åŠ¨
		layer.mesh.rotation.y += layer.speed;

		// æ›´æ–°æ˜Ÿæ˜Ÿçš„é—ªçƒæ•ˆæœ
		if (layer.geometry.attributes.alpha) {
		const alphas = layer.alphas;
		const speeds = layer.speeds;
		const newAlphas = new Float32Array(alphas.length);

		for (let i = 0; i < alphas.length; i++) {
		// ä½¿ç”¨æ­£å¼¦æ³¢åˆ›å»ºé—ªçƒæ•ˆæœ
		const twinkle = Math.sin(this.time * speeds[i]) * 0.3 + 0.7;
		newAlphas[i] = alphas[i] * twinkle;
		}

		// æ›´æ–°å‡ ä½•ä½“å±æ€§
		layer.geometry.setAttribute('alpha', new THREE.BufferAttribute(newAlphas, 1));
		layer.geometry.attributes.alpha.needsUpdate = true;
		}
		});
		}

		// åˆ‡æ¢æ˜Ÿç©ºæ˜¾ç¤º
		toggleStarfield() {
		this.starfieldEnabled = !this.starfieldEnabled;

		if (this.starfieldEnabled) {
		this.createImprovedStarfield();
		} else {
		this.starLayers.forEach(layer => this.scene.remove(layer.mesh));
		this.starLayers = [];
		}

		// æ›´æ–°æŒ‰é’®æ–‡æœ¬
		const button = document.getElementById('toggle-stars');
		button.textContent = this.starfieldEnabled ? 'å…³é—­æ˜Ÿç©º' : 'å¼€å¯æ˜Ÿç©º';
		}

		// åˆ›å»ºæ”¹è¿›çš„åœ°é¢
		createEnhancedGround() {
		// æ¸…ç©ºä¹‹å‰çš„åœ°é¢å¯¹è±¡
		if (this.groundObjects.length > 0) {
		this.groundObjects.forEach(obj => this.scene.remove(obj));
		this.groundObjects = [];
		}

		if (!this.groundEnabled) return;

		// ä¸»åœ°é¢å¹³é¢
		const groundGeometry = new THREE.PlaneGeometry(1000, 1000);

		if (this.groundType === 'grid') {
		// ç½‘æ ¼åœ°é¢
		const groundMaterial = new THREE.MeshPhongMaterial({
		color: 0x1a1d2b,
		side: THREE.DoubleSide,
		shininess: 10,
		specular: 0x222222
		});

		const ground = new THREE.Mesh(groundGeometry, groundMaterial);
		ground.rotation.x = -Math.PI / 2;
		ground.position.y = -0.1;
		this.scene.add(ground);
		this.groundObjects.push(ground);

		// æ·»åŠ ç²¾ç»†çš„ç½‘æ ¼çº¿
		this.createRefinedGridLines();

		} else if (this.groundType === 'marble') {
		// å¤§ç†çŸ³çº¹ç†åœ°é¢
		this.createMarbleGround();
		}

		// æ·»åŠ åœ°é¢åå°„æ•ˆæœ
		this.createGroundReflection();
		}

		// åˆ›å»ºç²¾è‡´çš„ç½‘æ ¼çº¿
		createRefinedGridLines() {
		const gridSize = 1000;
		const divisions = 200; // å¢åŠ ç»†åˆ†ï¼Œä½¿ç½‘æ ¼æ›´å¯†é›†
		const step = gridSize / divisions; // 5ç±³ä¸€æ ¼
		const halfSize = gridSize / 2;

		// åˆ›å»ºç½‘æ ¼çº¿ç»„
		const gridGroup = new THREE.Group();

		// ä¸»è¦ç½‘æ ¼çº¿ - æ›´ç»†ã€æ›´æ·¡
		const gridMaterial = new THREE.LineBasicMaterial({
		color: 0x3a3d4b, // æ›´æµ…çš„é¢œè‰²
		transparent: true,
		opacity: 0.08, // æ›´ä½çš„é€æ˜åº¦
		linewidth: 0.5
		});

		// Xè½´æ–¹å‘çš„çº¿
		for (let i = -divisions/2; i <= divisions/2; i++) {
		// æ¯10æ¡çº¿ä¸€æ¡ç¨ç²—çš„çº¿
		const isMajorLine = i % 10 === 0;
		const material = isMajorLine ?
		new THREE.LineBasicMaterial({
		color: 0x4a4d5b,
		transparent: true,
		opacity: 0.12,
		linewidth: 1
		}) :
		gridMaterial;

		const points = [];
		points.push(new THREE.Vector3(i * step, 0.02, -halfSize));
		points.push(new THREE.Vector3(i * step, 0.02, halfSize));

		const geometry = new THREE.BufferGeometry().setFromPoints(points);
		const line = new THREE.Line(geometry, material);
		gridGroup.add(line);
		}

		// Zè½´æ–¹å‘çš„çº¿
		for (let i = -divisions/2; i <= divisions/2; i++) {
		// æ¯10æ¡çº¿ä¸€æ¡ç¨ç²—çš„çº¿
		const isMajorLine = i % 10 === 0;
		const material = isMajorLine ?
		new THREE.LineBasicMaterial({
		color: 0x4a4d5b,
		transparent: true,
		opacity: 0.12,
		linewidth: 1
		}) :
		gridMaterial;

		const points = [];
		points.push(new THREE.Vector3(-halfSize, 0.02, i * step));
		points.push(new THREE.Vector3(halfSize, 0.02, i * step));

		const geometry = new THREE.BufferGeometry().setFromPoints(points);
		const line = new THREE.Line(geometry, material);
		gridGroup.add(line);
		}

		// ä¸­å¿ƒåæ ‡è½´ - æ›´æŸ”å’Œ
		const axisMaterial = new THREE.LineBasicMaterial({
		color: 0x5a7ddc, // æ›´æŸ”å’Œçš„è“è‰²
		transparent: true,
		opacity: 0.2,
		linewidth: 1.5
		});

		// Xè½´ï¼ˆçº¢è‰²ï¼‰
		const xAxisMaterial = new THREE.LineBasicMaterial({
		color: 0xff6b6b,
		transparent: true,
		opacity: 0.15,
		linewidth: 1.5
		});

		const xAxisPoints = [
		new THREE.Vector3(-20, 0.03, 0),
		new THREE.Vector3(20, 0.03, 0)
		];
		const xAxisGeometry = new THREE.BufferGeometry().setFromPoints(xAxisPoints);
		const xAxis = new THREE.Line(xAxisGeometry, xAxisMaterial);
		gridGroup.add(xAxis);

		// Zè½´ï¼ˆè“è‰²ï¼‰
		const zAxisMaterial = new THREE.LineBasicMaterial({
		color: 0x4d8aff,
		transparent: true,
		opacity: 0.15,
		linewidth: 1.5
		});

		const zAxisPoints = [
		new THREE.Vector3(0, 0.03, -20),
		new THREE.Vector3(0, 0.03, 20)
		];
		const zAxisGeometry = new THREE.BufferGeometry().setFromPoints(zAxisPoints);
		const zAxis = new THREE.Line(zAxisGeometry, zAxisMaterial);
		gridGroup.add(zAxis);

		// æ·»åŠ ä¸­å¿ƒç‚¹æ ‡è®°
		const centerGeometry = new THREE.SphereGeometry(0.1, 8, 8);
		const centerMaterial = new THREE.MeshBasicMaterial({
		color: 0xffffff,
		transparent: true,
		opacity: 0.3
		});
		const centerPoint = new THREE.Mesh(centerGeometry, centerMaterial);
		centerPoint.position.set(0, 0.04, 0);
		gridGroup.add(centerPoint);

		this.scene.add(gridGroup);
		this.groundObjects.push(gridGroup);
		}

		// åˆ›å»ºå¤§ç†çŸ³åœ°é¢
		createMarbleGround() {
		// åˆ›å»ºç¨‹åºåŒ–å¤§ç†çŸ³çº¹ç†
		const canvas = document.createElement('canvas');
		canvas.width = 1024;
		canvas.height = 1024;
		const ctx = canvas.getContext('2d');

		// åˆ›å»ºå¤§ç†çŸ³çº¹ç†
		const baseColor = '#1a1d2b';
		const veinColor = '#2a2d3b';

		// å¡«å……åŸºç¡€é¢œè‰²
		ctx.fillStyle = baseColor;
		ctx.fillRect(0, 0, canvas.width, canvas.height);

		// ç»˜åˆ¶å¤§ç†çŸ³çº¹ç†
		ctx.strokeStyle = veinColor;
		ctx.lineWidth = 0.3;
		ctx.globalAlpha = 0.08;

		// åˆ›å»ºéšæœºçº¹ç†çº¿æ¡
		for (let i = 0; i < 80; i++) {
		ctx.beginPath();
		const startX = Math.random() * canvas.width;
		const startY = Math.random() * canvas.height;
		ctx.moveTo(startX, startY);

		for (let j = 0; j < 15; j++) {
		const endX = startX + (Math.random() - 0.5) * 150;
		const endY = startY + (Math.random() - 0.5) * 150;
		ctx.lineTo(endX, endY);
		}
		ctx.stroke();
		}

		// æ·»åŠ ä¸€äº›æ–‘ç‚¹
		ctx.fillStyle = veinColor;
		ctx.globalAlpha = 0.03;
		for (let i = 0; i < 300; i++) {
		const x = Math.random() * canvas.width;
		const y = Math.random() * canvas.height;
		const radius = Math.random() * 2 + 0.5;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2);
		ctx.fill();
		}

		// åˆ›å»ºçº¹ç†
		const texture = new THREE.CanvasTexture(canvas);
		texture.wrapS = THREE.RepeatWrapping;
		texture.wrapT = THREE.RepeatWrapping;
		texture.repeat.set(8, 8);

		// åˆ›å»ºåœ°é¢æè´¨
		const groundMaterial = new THREE.MeshPhongMaterial({
		map: texture,
		side: THREE.DoubleSide,
		shininess: 25,
		specular: 0x222222
		});

		const groundGeometry = new THREE.PlaneGeometry(1000, 1000);
		const ground = new THREE.Mesh(groundGeometry, groundMaterial);
		ground.rotation.x = -Math.PI / 2;
		ground.position.y = -0.1;
		this.scene.add(ground);
		this.groundObjects.push(ground);

		// æ·»åŠ å¾®å¦™çš„ç½‘æ ¼çº¿
		this.createSubtleGrid();
		}

		// åˆ›å»ºå¾®å¦™çš„ç½‘æ ¼çº¿
		createSubtleGrid() {
		const gridGroup = new THREE.Group();
		const gridMaterial = new THREE.LineBasicMaterial({
		color: 0x3a3d4b,
		transparent: true,
		opacity: 0.03
		});

		const gridSize = 1000;
		const divisions = 50;
		const step = gridSize / divisions;
		const halfSize = gridSize / 2;

		for (let i = -divisions/2; i <= divisions/2; i++) {
		// Xæ–¹å‘
		const xPoints = [
		new THREE.Vector3(i * step, 0.02, -halfSize),
		new THREE.Vector3(i * step, 0.02, halfSize)
		];
		const xGeometry = new THREE.BufferGeometry().setFromPoints(xPoints);
		const xLine = new THREE.Line(xGeometry, gridMaterial);
		gridGroup.add(xLine);

		// Zæ–¹å‘
		const zPoints = [
		new THREE.Vector3(-halfSize, 0.02, i * step),
		new THREE.Vector3(halfSize, 0.02, i * step)
		];
		const zGeometry = new THREE.BufferGeometry().setFromPoints(zPoints);
		const zLine = new THREE.Line(zGeometry, gridMaterial);
		gridGroup.add(zLine);
		}

		this.scene.add(gridGroup);
		this.groundObjects.push(gridGroup);
		}

		// åˆ›å»ºåœ°é¢åå°„æ•ˆæœ
		createGroundReflection() {
		// åˆ›å»ºä¸€ä¸ªé€æ˜çš„åå°„å¹³é¢
		const reflectionGeometry = new THREE.PlaneGeometry(1000, 1000);
		const reflectionMaterial = new THREE.MeshBasicMaterial({
		color: 0xffffff,
		transparent: true,
		opacity: 0.01,
		side: THREE.DoubleSide
		});

		this.groundReflection = new THREE.Mesh(reflectionGeometry, reflectionMaterial);
		this.groundReflection.rotation.x = -Math.PI / 2;
		this.groundReflection.position.y = 0.01;
		this.scene.add(this.groundReflection);
		this.groundObjects.push(this.groundReflection);
		}

		// åˆ‡æ¢åœ°é¢ç±»å‹
		toggleGroundType() {
		this.groundType = this.groundType === 'grid' ? 'marble' : 'grid';
		this.createEnhancedGround();

		// æ›´æ–°æŒ‰é’®æ–‡æœ¬
		const button = document.getElementById('toggle-ground');
		button.textContent = this.groundType === 'grid' ? 'å¤§ç†çŸ³åœ°é¢' : 'ç½‘æ ¼åœ°é¢';
		}

		setupFirstPersonControls() {
		// ç§»åŠ¨çŠ¶æ€
		this.moveState = {
		forward: false,
		backward: false,
		left: false,
		right: false,
		run: false
		};

		// ç§»åŠ¨é€Ÿåº¦
		this.moveSpeed = {
		walk: 0.1,
		run: 0.2
		};

		// é¼ æ ‡æ§åˆ¶
		this.mouse = new THREE.Vector2();
		this.rotation = {
		x: 0,
		y: 0
		};

		// é”å®šæŒ‡é’ˆ
		this.renderer.domElement.addEventListener('click', () => {
		if (!this.isPointerLocked) {
		this.renderer.domElement.requestPointerLock();
		}
		});

		// æŒ‡é’ˆé”å®šå˜åŒ–äº‹ä»¶
		document.addEventListener('pointerlockchange', () => {
		if (document.pointerLockElement === this.renderer.domElement) {
		this.isPointerLocked = true;
		document.addEventListener('mousemove', this.onMouseMove.bind(this));
		} else {
		this.isPointerLocked = false;
		document.removeEventListener('mousemove', this.onMouseMove.bind(this));
		}
		});

		// é¼ æ ‡å³é”®äº‹ä»¶ - é€€å‡ºæŒ‡é’ˆé”å®š
		this.renderer.domElement.addEventListener('mousedown', (event) => {
		if (event.button === 2) { // å³é”®çš„buttonå€¼æ˜¯2
		if (this.isPointerLocked) {
		document.exitPointerLock();
		}
		event.preventDefault(); // é˜»æ­¢é»˜è®¤è¡Œä¸º
		}
		});

		// é˜»æ­¢å³é”®èœå•åœ¨ç”»å¸ƒä¸Šå¼¹å‡º
		this.renderer.domElement.addEventListener('contextmenu', (event) => {
		event.preventDefault();
		});

		// é”®ç›˜äº‹ä»¶
		document.addEventListener('keydown', this.onKeyDown.bind(this));
		document.addEventListener('keyup', this.onKeyUp.bind(this));

		// çª—å£å¤§å°è°ƒæ•´
		window.addEventListener('resize', this.onWindowResize.bind(this));
		}

		onMouseMove(event) {
		if (!this.isPointerLocked) return;

		this.mouse.x = event.movementX;
		this.mouse.y = event.movementY;

		// æ›´æ–°ç›¸æœºæ—‹è½¬
		this.rotation.x -= this.mouse.y * 0.0015;
		this.rotation.y -= this.mouse.x * 0.0015;

		// é™åˆ¶å‚ç›´è§†è§’
		this.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, this.rotation.x));

		// æ›´æ–°ç›¸æœºæ–¹å‘
		this.camera.rotation.order = 'YXZ';
		this.camera.rotation.y = this.rotation.y;
		this.camera.rotation.x = this.rotation.x;

		// æ›´æ–°ç§»åŠ¨æ—¶é—´
		this.updateLastMoveTime();
		}

		onKeyDown(event) {
		this.updateLastMoveTime();

		switch(event.code) {
		case 'KeyW':
		this.moveState.forward = true;
		break;
		case 'KeyS':
		this.moveState.backward = true;
		break;
		case 'KeyA':
		this.moveState.left = true;
		break;
		case 'KeyD':
		this.moveState.right = true;
		break;
		case 'ShiftLeft':
		this.moveState.run = true;
		break;
		case 'Tab':
		event.preventDefault(); // é˜²æ­¢Tabé”®çš„é»˜è®¤è¡Œä¸º
		this.toggleImmersiveMode();
		break;
		case 'Escape':
		if (document.pointerLockElement) {
		document.exitPointerLock();
		}
		break;
		case 'ArrowLeft':  // æ·»åŠ å·¦æ–¹å‘é”®å¤„ç†
		this.seekVideo(-5);  // å¿«é€€5ç§’
		break;
		case 'ArrowRight': // æ·»åŠ å³æ–¹å‘é”®å¤„ç†
		this.seekVideo(5);   // å¿«è¿›5ç§’
		break;
		}
		}

		onKeyUp(event) {
		switch(event.code) {
		case 'KeyW':
		this.moveState.forward = false;
		break;
		case 'KeyS':
		this.moveState.backward = false;
		break;
		case 'KeyA':
		this.moveState.left = false;
		break;
		case 'KeyD':
		this.moveState.right = false;
		break;
		case 'ShiftLeft':
		this.moveState.run = false;
		break;
		}
		}

		onContextMenu(event) {
		event.preventDefault(); // å§‹ç»ˆé˜»æ­¢é»˜è®¤å³é”®èœå•

		// å¦‚æœæŒ‡é’ˆå·²é”å®šï¼Œåˆ™é€€å‡ºé”å®š
		if (this.isPointerLocked) {
		document.exitPointerLock();
		return;
		}
		}

		updateLastMoveTime() {
		this.lastMoveTime = Date.now();

		// æ˜¾ç¤ºå‡†æ˜Ÿ
		if (!this.crosshairVisible) {
		this.crosshairVisible = true;
		document.getElementById('crosshair').classList.remove('hidden');
		}
		}

		updateMovement() {
		// è®¡ç®—ç§»åŠ¨æ–¹å‘ï¼ˆä»…åœ¨æ°´å¹³é¢ç§»åŠ¨ï¼‰
		const direction = new THREE.Vector3();
		this.camera.getWorldDirection(direction);
		direction.y = 0; // ç¦æ­¢å‚ç›´æ–¹å‘ç§»åŠ¨
		direction.normalize();

		// è®¡ç®—ä¾§å‘å‘é‡ï¼ˆä»…åœ¨æ°´å¹³é¢ç§»åŠ¨ï¼‰
		const sideVector = new THREE.Vector3();
		sideVector.crossVectors(new THREE.Vector3(0, 1, 0), direction).normalize();

		// æ ¹æ®ç§»åŠ¨çŠ¶æ€æ›´æ–°ä½ç½®
		const speed = this.moveState.run ? this.moveSpeed.run : this.moveSpeed.walk;

		if (this.moveState.forward) {
		this.camera.position.add(direction.multiplyScalar(speed));
		}
		if (this.moveState.backward) {
		this.camera.position.add(direction.multiplyScalar(-speed));
		}
		if (this.moveState.left) {
		this.camera.position.add(sideVector.multiplyScalar(speed));
		}
		if (this.moveState.right) {
		this.camera.position.add(sideVector.multiplyScalar(-speed));
		}

		// ç¡®ä¿äººç‰©é«˜åº¦å›ºå®šä¸º1.7ç±³
		this.camera.position.y = 1.7;

		// æ£€æŸ¥æ˜¯å¦éœ€è¦éšè—å‡†æ˜Ÿï¼ˆ3ç§’ä¸åŠ¨ï¼‰
		if (Date.now() - this.lastMoveTime > 3000 && this.crosshairVisible) {
		this.crosshairVisible = false;
		document.getElementById('crosshair').classList.add('hidden');
		}
		}

		onWindowResize() {
		this.camera.aspect = window.innerWidth / window.innerHeight;
		this.camera.updateProjectionMatrix();
		this.renderer.setSize(window.innerWidth, window.innerHeight);
		}

		toggleImmersiveMode() {
		this.isImmersive = !this.isImmersive;

		const ui = document.getElementById('ui');
		const instructions = document.getElementById('instructions');
		const performanceStats = document.getElementById('performance-stats');

		if (this.isImmersive) {
		ui.classList.add('hidden');
		instructions.classList.add('hidden');
		performanceStats.classList.add('hidden');
		} else {
		ui.classList.remove('hidden');
		instructions.classList.remove('hidden');
		performanceStats.classList.remove('hidden');
		}
		}

		togglePerformanceMode() {
		this.performanceMode = !this.performanceMode;

		// æ›´æ–°UI
		const button = document.getElementById('performance-toggle');
		button.textContent = this.performanceMode ? 'æ­£å¸¸æ¨¡å¼' : 'æ€§èƒ½æ¨¡å¼';

		// åº”ç”¨æ€§èƒ½æ¨¡å¼è®¾ç½®
		this.applyPerformanceSettings();
		}

		applyPerformanceSettings() {
		if (this.performanceMode) {
		// æ€§èƒ½æ¨¡å¼ï¼šé™ä½æ¸²æŸ“è´¨é‡
		this.renderer.setPixelRatio(1);
		this.maxVisibleMedia = 15;
		this.viewDistance = 30;
		this.spawnDistance = 25;
		this.unloadDistance = 40;

		// å…³é—­æ˜Ÿç©ºå’Œåœ°é¢æ•ˆæœ
		this.starfieldEnabled = false;
		this.groundEnabled = false;
		this.createEnhancedGround();
		if (this.starLayers.length > 0) {
		this.starLayers.forEach(layer => this.scene.remove(layer.mesh));
		this.starLayers = [];
		}
		} else {
		// æ­£å¸¸æ¨¡å¼ï¼šæ¢å¤é»˜è®¤è®¾ç½®
		this.renderer.setPixelRatio(window.devicePixelRatio);
		this.maxVisibleMedia = 40;
		this.viewDistance = 70;
		this.spawnDistance = 70;
		this.unloadDistance = 70;

		// æ¢å¤æ˜Ÿç©ºå’Œåœ°é¢æ•ˆæœ
		this.starfieldEnabled = true;
		this.groundEnabled = true;
		this.createEnhancedGround();
		this.createImprovedStarfield();
		}

		// é‡æ–°è¯„ä¼°æ‰€æœ‰åª’ä½“çš„å¯è§æ€§
		this.evaluateMediaVisibility();
		}

		setupEventListeners() {
		const fileInput = document.getElementById('file-input');

		// æ–‡ä»¶å¯¼å…¥ - æ–‡ä»¶å¤¹
		document.getElementById('import-folder').addEventListener('click', () => {
		// è®¾ç½®æ–‡ä»¶å¤¹é€‰æ‹©æ¨¡å¼
		fileInput.setAttribute('webkitdirectory', '');
		fileInput.setAttribute('directory', '');
		fileInput.setAttribute('multiple', '');
		fileInput.accept = 'image/*,video/*'; // é™åˆ¶æ–‡ä»¶ç±»å‹
		fileInput.click();
		console.log('æ–‡ä»¶å¤¹é€‰æ‹©æ¨¡å¼å·²æ¿€æ´»');
		});

		// æ–‡ä»¶å¯¼å…¥ - å•ä¸ªæ–‡ä»¶
		document.getElementById('import-files').addEventListener('click', () => {
		// ç§»é™¤æ–‡ä»¶å¤¹å±æ€§ï¼Œè®¾ç½®ä¸ºå¤šæ–‡ä»¶é€‰æ‹©
		fileInput.removeAttribute('webkitdirectory');
		fileInput.removeAttribute('directory');
		fileInput.setAttribute('multiple', '');
		fileInput.accept = 'image/*,video/*'; // é™åˆ¶æ–‡ä»¶ç±»å‹
		fileInput.click();
		console.log('æ–‡ä»¶é€‰æ‹©æ¨¡å¼å·²æ¿€æ´»');
		});

		// æ–‡ä»¶é€‰æ‹©å¤„ç†
		fileInput.addEventListener('change', (event) => {
		const files = event.target.files;
		console.log('é€‰æ‹©çš„æ–‡ä»¶æ•°é‡:', files.length);

		if (files.length > 0) {
		// æ˜¾ç¤ºæ–‡ä»¶ä¿¡æ¯ç”¨äºè°ƒè¯•
		for (let i = 0; i < Math.min(files.length, 5); i++) {
		const file = files[i];
		console.log(`æ–‡ä»¶ ${i + 1}:`, file.name,
		'ç±»å‹:', file.type,
		'è·¯å¾„:', file.webkitRelativePath || file.name);
		}
		if (files.length > 5) {
		console.log(`... è¿˜æœ‰ ${files.length - 5} ä¸ªæ–‡ä»¶`);
		}

		this.handleFiles(files);
		} else {
		console.log('æ²¡æœ‰é€‰æ‹©æ–‡ä»¶');
		}

		// é‡ç½®input
		event.target.value = '';

		// é‡ç½®æ–‡ä»¶è¾“å…¥å±æ€§
		fileInput.removeAttribute('webkitdirectory');
		fileInput.removeAttribute('directory');
		});

		// ç§»é™¤æ‰€æœ‰åª’ä½“
		document.getElementById('remove-all').addEventListener('click', () => {
		this.removeAllMedia();
		});

		// äººç‰©å¤ä½
		document.getElementById('reset-position').addEventListener('click', () => {
		this.resetPosition();
		});

		// æ€§èƒ½æ¨¡å¼åˆ‡æ¢
		document.getElementById('performance-toggle').addEventListener('click', () => {
		this.togglePerformanceMode();
		});

		// åœ°é¢åˆ‡æ¢
		document.getElementById('toggle-ground').addEventListener('click', () => {
		this.toggleGroundType();
		});

		// æ˜Ÿç©ºåˆ‡æ¢
		document.getElementById('toggle-stars').addEventListener('click', () => {
		this.toggleStarfield();
		});

		// è§†é¢‘æ§åˆ¶äº‹ä»¶
		this.setupVideoControls();

		// æ£€æŸ¥æ–‡ä»¶å¤¹é€‰æ‹©æ”¯æŒ
		this.checkFolderSelectionSupport();

		// æ·»åŠ å…¨å±åˆ‡æ¢
		document.addEventListener('keydown', (e) => {
		if (e.code === 'F11') {
		e.preventDefault();
		if (!document.fullscreenElement) {
		document.documentElement.requestFullscreen();
		} else {
		document.exitFullscreen();
		}
		}
		});
		}

		// æ·»åŠ æ–‡ä»¶å¤¹é€‰æ‹©æ”¯æŒæ£€æŸ¥
		checkFolderSelectionSupport() {
		const fileInput = document.getElementById('file-input');
		const folderButton = document.getElementById('import-folder');

		if (!fileInput.webkitdirectory && !fileInput.directory) {
		console.warn('æµè§ˆå™¨ä¸æ”¯æŒæ–‡ä»¶å¤¹é€‰æ‹©');
		folderButton.style.opacity = '0.5';
		folderButton.title = 'æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ–‡ä»¶å¤¹é€‰æ‹©åŠŸèƒ½';
		folderButton.addEventListener('click', (e) => {
		e.preventDefault();
		alert('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ–‡ä»¶å¤¹é€‰æ‹©åŠŸèƒ½ã€‚è¯·ä½¿ç”¨Chromeã€Edgeæˆ–Firefoxç­‰ç°ä»£æµè§ˆå™¨ã€‚');
		});
		} else {
		console.log('æµè§ˆå™¨æ”¯æŒæ–‡ä»¶å¤¹é€‰æ‹©');
		}
		}

		setupVideoControls() {
		const playPauseBtn = document.getElementById('play-pause-btn');
		const muteBtn = document.getElementById('mute-btn');
		const progressSlider = document.getElementById('progress-slider');
		const volumeSlider = document.getElementById('volume-slider');

		playPauseBtn.addEventListener('click', () => {
		if (this.currentlyPlaying && this.currentlyPlaying.element) {
		if (this.currentlyPlaying.isPlaying) {
		this.pauseMedia(this.currentlyPlaying);
		playPauseBtn.textContent = 'æ’­æ”¾';
		} else {
		this.playMedia(this.currentlyPlaying);
		playPauseBtn.textContent = 'æš‚åœ';
		}
		}
		});

		muteBtn.addEventListener('click', () => {
		if (this.currentlyPlaying && this.currentlyPlaying.element) {
		this.currentlyPlaying.element.muted = !this.currentlyPlaying.element.muted;
		muteBtn.textContent = this.currentlyPlaying.element.muted ? 'å–æ¶ˆé™éŸ³' : 'é™éŸ³';
		}
		});

		// è¿›åº¦æ¡æ§åˆ¶
		progressSlider.addEventListener('click', (e) => {
		if (this.currentlyPlaying && this.currentlyPlaying.element) {
		const rect = progressSlider.getBoundingClientRect();
		const percent = (e.clientX - rect.left) / rect.width;
		this.currentlyPlaying.element.currentTime = percent * this.currentlyPlaying.element.duration;
		}
		});

		// éŸ³é‡æ§åˆ¶
		volumeSlider.addEventListener('click', (e) => {
		if (this.currentlyPlaying && this.currentlyPlaying.element) {
		const rect = volumeSlider.getBoundingClientRect();
		const volume = (e.clientX - rect.left) / rect.width;
		this.currentlyPlaying.element.volume = Math.max(0, Math.min(1, volume));
		this.updateVideoControlsUI();
		}
		});
		}

		updateVideoControlsUI() {
		if (!this.currentlyPlaying || !this.currentlyPlaying.element) return;

		const video = this.currentlyPlaying.element;
		const progressBar = document.getElementById('progress-bar');
		const progressHandle = document.getElementById('progress-handle');
		const volumeBar = document.getElementById('volume-bar');
		const volumeHandle = document.getElementById('volume-handle');
		const playPauseBtn = document.getElementById('play-pause-btn');
		const muteBtn = document.getElementById('mute-btn');

		// æ›´æ–°è¿›åº¦æ¡
		if (video.duration) {
		const progressPercent = (video.currentTime / video.duration) * 100;
		progressBar.style.width = `${progressPercent}%`;
		progressHandle.style.left = `${progressPercent}%`;
		}

		// æ›´æ–°éŸ³é‡æ¡
		const volumePercent = video.volume * 100;
		volumeBar.style.width = `${volumePercent}%`;
		volumeHandle.style.left = `${volumePercent}%`;

		// æ›´æ–°æŒ‰é’®çŠ¶æ€
		playPauseBtn.textContent = video.paused ? 'æ’­æ”¾' : 'æš‚åœ';
		muteBtn.textContent = video.muted ? 'å–æ¶ˆé™éŸ³' : 'é™éŸ³';
		}

		showVideoControls() {
		this.videoControlsVisible = true;
		document.getElementById('video-controls').classList.remove('hidden');
		this.updateVideoControlsUI();
		}

		hideVideoControls() {
		this.videoControlsVisible = false;
		document.getElementById('video-controls').classList.add('hidden');
		}

		handleFiles(files) {
		console.log('å¼€å§‹å¤„ç†æ–‡ä»¶ï¼Œæ€»æ•°:', files.length);

		let supportedCount = 0;
		let unsupportedCount = 0;
		let imageCount = 0;
		let videoCount = 0;
		let gifCount = 0;

		// æ¸…ç©ºåŠ è½½é˜Ÿåˆ—
		this.loadingQueue = [];

		for (let i = 0; i < files.length; i++) {
		const file = files[i];
		const fileType = file.type.split('/')[0];

		// æ”¯æŒçš„æ–‡ä»¶ç±»å‹
		const isImage = fileType === 'image';
		const isVideo = fileType === 'video';
		const isGif = file.type === 'image/gif';

		if (isImage || isVideo) {
		this.loadingQueue.push(file);
		supportedCount++;

		if (isImage) imageCount++;
		if (isVideo) videoCount++;
		if (isGif) gifCount++;
		} else {
		console.log(`è·³è¿‡ä¸æ”¯æŒçš„æ–‡ä»¶: ${file.name} (${file.type})`);
		unsupportedCount++;
		}
		}

		// è®¾ç½®åŠ è½½å‚æ•°
		this.totalToLoad = supportedCount;
		this.loadedCount = 0;

		// æ˜¾ç¤ºåŠ è½½ç•Œé¢
		this.showLoadingOverlay();

		// å¼€å§‹å¤„ç†é˜Ÿåˆ—
		this.processLoadingQueue();

		console.log(`å¤„ç†å®Œæˆ: ${supportedCount} ä¸ªæ”¯æŒçš„æ–‡ä»¶ (${imageCount} å›¾ç‰‡, ${videoCount} è§†é¢‘, ${gifCount} GIF), ${unsupportedCount} ä¸ªä¸æ”¯æŒçš„æ–‡ä»¶`);

		// æ˜¾ç¤ºå¤„ç†ç»“æœ
		if (supportedCount > 0) {
		const message = `æˆåŠŸå¯¼å…¥ ${supportedCount} ä¸ªåª’ä½“æ–‡ä»¶\n` +
		`- å›¾ç‰‡: ${imageCount}\n` +
		`- è§†é¢‘: ${videoCount}\n` +
		`- GIF: ${gifCount}`;
		console.log(message);
		} else if (files.length > 0) {
		alert('æ²¡æœ‰æ‰¾åˆ°æ”¯æŒçš„å›¾ç‰‡æˆ–è§†é¢‘æ–‡ä»¶ã€‚\nè¯·é€‰æ‹© JPEGã€PNGã€GIF å›¾ç‰‡æˆ– MP4ã€WebM è§†é¢‘æ–‡ä»¶ã€‚');
		}
		}

		showLoadingOverlay() {
		const overlay = document.getElementById('loading-overlay');
		const loadingText = document.getElementById('loading-text');
		const loadingBar = document.getElementById('loading-bar');

		loadingText.textContent = 'æ­£åœ¨åŠ è½½åª’ä½“æ–‡ä»¶...';
		loadingBar.style.width = '0%';
		overlay.classList.remove('hidden');
		}

		hideLoadingOverlay() {
		const overlay = document.getElementById('loading-overlay');
		overlay.classList.add('hidden');
		}

		updateLoadingProgress() {
		const progress = (this.loadedCount / this.totalToLoad) * 100;
		const loadingBar = document.getElementById('loading-bar');
		const loadingText = document.getElementById('loading-text');

		loadingBar.style.width = `${progress}%`;
		loadingText.textContent = `æ­£åœ¨åŠ è½½åª’ä½“æ–‡ä»¶... ${this.loadedCount}/${this.totalToLoad}`;

		if (this.loadedCount >= this.totalToLoad) {
		setTimeout(() => {
		this.hideLoadingOverlay();
		}, 500);
		}
		}

		processLoadingQueue() {
		if (this.loadingQueue.length === 0) {
		this.isLoading = false;
		return;
		}

		this.isLoading = true;

		// æ¯æ¬¡å¤„ç†5ä¸ªæ–‡ä»¶ï¼Œé¿å…é˜»å¡ä¸»çº¿ç¨‹
		const batchSize = 5;
		const batch = this.loadingQueue.splice(0, batchSize);

		let processedInBatch = 0;

		batch.forEach(file => {
		this.createMediaObject(file, () => {
		processedInBatch++;
		this.loadedCount++;
		this.updateLoadingProgress();

		if (processedInBatch >= batch.length) {
		// ç»§ç»­å¤„ç†ä¸‹ä¸€æ‰¹
		setTimeout(() => {
		this.processLoadingQueue();
		}, 0);
		}
		});
		});
		}

		createMediaObject(file, onLoadComplete) {
		// æ£€æŸ¥æ˜¯å¦è¶…è¿‡æœ€å¤§åª’ä½“æ•°é‡é™åˆ¶
		if (this.mediaObjects.length >= this.maxMediaObjects) {
		// æ‰¾åˆ°æœ€è¿œçš„åª’ä½“å¯¹è±¡è¿›è¡Œæ›¿æ¢
		this.unloadFarthestMedia();
		}

		const fileType = file.type.split('/')[0];
		const fileExtension = file.name.split('.').pop().toUpperCase();

		// åˆ›å»ºåª’ä½“å¯¹è±¡
		const mediaObject = {
		file: file,
		type: fileType,
		extension: fileExtension,
		element: null,
		texture: null,
		mesh: null,
		isPlaying: false,
		isVideo: fileType === 'video',
		isGif: file.type === 'image/gif',
		labelMesh: null,
		lastSeen: Date.now(),
		distance: 0,
		gridKey: null,
		isVisible: false,
		priority: Math.random() // æ·»åŠ ä¼˜å…ˆçº§å­—æ®µï¼Œç”¨äºæ— åºåŠ è½½
		};

		// åˆ›å»ºåª’ä½“å¹³é¢ - ä½¿ç”¨ç®€çº¦æè´¨
		const geometry = new THREE.PlaneGeometry(1, 1);
		const material = new THREE.MeshBasicMaterial({
		side: THREE.DoubleSide, // æ­£åé¢äº®åº¦ä¸€è‡´
		transparent: true
		});

		const mesh = new THREE.Mesh(geometry, material);

		// åˆå§‹ä½ç½®è®¾ç½®ä¸ºè¿œç¦»è§†é‡
		mesh.position.set(1000, 0, 1000);

		// è®¾ç½®åª’ä½“é«˜åº¦
		mesh.position.y = 1.85; // 0.3ç±³è·åœ°é¢ + 1.7ç±³äººç‰©é«˜åº¦çš„ä¸€åŠ

		this.scene.add(mesh);
		mediaObject.mesh = mesh;

		// åŠ è½½åª’ä½“å†…å®¹
		this.loadMediaContent(mediaObject, onLoadComplete);

		this.mediaObjects.push(mediaObject);

		// æ›´æ–°åª’ä½“è®¡æ•°æ˜¾ç¤º
		this.updatePerformanceStats();
		}

		// è·å–ç½‘æ ¼é”®å€¼
		getGridKey(position) {
		const gridX = Math.round(position.x / this.gridSize);
		const gridZ = Math.round(position.z / this.gridSize);
		return `${gridX},${gridZ}`;
		}

		// æ£€æŸ¥ä½ç½®æ˜¯å¦å¯ç”¨
		isPositionAvailable(position) {
			const gridKey = this.getGridKey(position);

			// æ£€æŸ¥æ˜¯å¦å·²è¢«å ç”¨
			if (this.occupiedGrids.has(gridKey)) {
				return false;
			}

			// æ£€æŸ¥æ˜¯å¦ä¸å…¶ä»–å¯è§åª’ä½“è·ç¦»è¿‡è¿‘
			for (const obj of this.visibleMedia) {
				if (obj.mesh && position.distanceTo(obj.mesh.position) < this.minSpacing) {
					return false;
				}
			}
			
			// æ£€æŸ¥æ˜¯å¦åœ¨é‡ç”Ÿç‚¹æ’é™¤åŠå¾„å†…
			const distanceToSpawn = position.distanceTo(this.spawnPoint);
			if (distanceToSpawn < this.spawnExclusionRadius) {
				return false;
			}

			return true;
		}

		// ä¿®æ”¹ï¼šè·å–ç¯å½¢åŒºåŸŸå†…çš„å¯ç”¨ä½ç½®ï¼ˆç”±è¿‘åˆ°è¿œï¼‰
		getAvailablePositionInRing() {
			const cameraPos = this.camera.position;
			const attemptsPerRing = 20; // æ¯ä¸ªè·ç¦»ç¯çš„å°è¯•æ¬¡æ•°
		
			// ä»æœ€è¿‘è·ç¦»å¼€å§‹ï¼Œé€æ­¥å‘å¤–å¯»æ‰¾
			for (let distance = this.minDistance; distance <= this.spawnDistance; distance += this.minSpacing * 0.8) {
				for (let attempt = 0; attempt < attemptsPerRing; attempt++) {
					// åœ¨ç¯å½¢åŒºåŸŸéšæœºè§’åº¦
					const angle = Math.random() * Math.PI * 2;
		
					const position = new THREE.Vector3(
						cameraPos.x + Math.cos(angle) * distance,
						0,
						cameraPos.z + Math.sin(angle) * distance
					);

					// ä½¿ç”¨ç»Ÿä¸€çš„ isPositionAvailable æ–¹æ³•æ£€æŸ¥ä½ç½®
					if (this.isPositionAvailable(position)) {
						return { position, distance };
					}
				}
			}

			// å¦‚æœæ‰¾ä¸åˆ°åˆé€‚ä½ç½®ï¼Œè¿”å›null
			return null;
		}

		// ä¿®æ”¹ï¼šåŠ¨æ€ç”Ÿæˆåª’ä½“ - æ— åºæ–¹å¼ç”±è¿‘åˆ°è¿œ
		spawnMedia() {
		const now = Date.now();

		// æ§åˆ¶ç”Ÿæˆé¢‘ç‡
		if (now - this.lastSpawnCheck < this.spawnInterval) {
		return;
		}

		this.lastSpawnCheck = now;

		// å¦‚æœå¯è§åª’ä½“æ•°é‡å·²è¾¾ä¸Šé™ï¼Œä¸ç”Ÿæˆæ–°åª’ä½“
		if (this.visibleMedia.length >= this.maxVisibleMedia) {
		return;
		}

		// æŸ¥æ‰¾æœªæ˜¾ç¤ºçš„åª’ä½“ï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åºï¼ˆå®ç°æ— åºåŠ è½½ï¼‰
		const availableMedia = this.mediaObjects.filter(obj =>
		!obj.isVisible && obj.mesh && obj.texture
		).sort((a, b) => a.priority - b.priority);

		if (availableMedia.length === 0) {
		return;
		}

		// é€‰æ‹©ä¸€ä¸ªåª’ä½“ï¼ˆåŸºäºä¼˜å…ˆçº§ï¼Œå®ç°æ— åºåŠ è½½ï¼‰
		const mediaObject = availableMedia[0];

		// è·å–å¯ç”¨ä½ç½®ï¼ˆç”±è¿‘åˆ°è¿œï¼‰
		const positionData = this.getAvailablePositionInRing();

		if (positionData) {
		const { position, distance } = positionData;
		
		// è®¾ç½®ä½ç½®
		mediaObject.mesh.position.copy(position);
		mediaObject.mesh.position.y = 1.85;

		// è®¾ç½®åª’ä½“æœå‘å‡ºç”Ÿç‚¹ (0, 1.7, 0) è€Œä¸æ˜¯ç›¸æœº
		const direction = new THREE.Vector3();
		const spawnPoint = new THREE.Vector3(0, 1.7, 0); // å‡ºç”Ÿç‚¹
		direction.subVectors(spawnPoint, mediaObject.mesh.position);
		direction.y = 0; // åªåœ¨æ°´å¹³é¢æ—‹è½¬

		// è®¾ç½®åª’ä½“æœå‘å‡ºç”Ÿç‚¹
		mediaObject.mesh.lookAt(
		mediaObject.mesh.position.x + direction.x,
		mediaObject.mesh.position.y,
		mediaObject.mesh.position.z + direction.z
		);

		// æ ‡è®°ä¸ºå¯è§
		mediaObject.isVisible = true;
		mediaObject.mesh.visible = true;
		if (mediaObject.labelMesh) mediaObject.labelMesh.visible = true;
		
		// æ›´æ–°è·ç¦»
		mediaObject.distance = distance;

		// è®°å½•ç½‘æ ¼å ç”¨
		const gridKey = this.getGridKey(position);
		mediaObject.gridKey = gridKey;
		this.occupiedGrids.add(gridKey);

		// æ·»åŠ åˆ°å¯è§åª’ä½“åˆ—è¡¨
		this.visibleMedia.push(mediaObject);
		
		console.log(`åª’ä½“ ${mediaObject.file.name} ç”Ÿæˆåœ¨è·ç¦» ${distance.toFixed(1)} ç±³å¤„`);
		}
		}

		loadMediaContent(mediaObject, onLoadComplete) {
		const file = mediaObject.file;
		const mesh = mediaObject.mesh;

		if (mediaObject.type === 'image') {
		if (mediaObject.isGif) {
		// å¤„ç†GIF
		this.loadGif(mediaObject, onLoadComplete);
		} else {
		// å¤„ç†é™æ€å›¾ç‰‡
		const reader = new FileReader();

		reader.onload = (event) => {
		const img = new Image();

		img.onload = () => {
		// æ ¹æ®å›¾ç‰‡æ¯”ä¾‹è°ƒæ•´å¤§å°
		const aspect = img.width / img.height;
		const height = 3.2; // 3.5ç±³é¡¶è¾¹é«˜åº¦ - 0.3ç±³è·åœ°é¢
		const width = height * aspect;

		mesh.scale.set(width, height, 1);

		// åˆ›å»ºçº¹ç†
		const texture = new THREE.Texture(img);
		texture.needsUpdate = true;

		mediaObject.texture = texture;
		mesh.material.map = texture;
		mesh.material.needsUpdate = true;

		// æ·»åŠ æ‰©å±•åæ ‡ç­¾
		this.addExtensionLabel(mediaObject);

		// è°ƒç”¨å®Œæˆå›è°ƒ
		if (onLoadComplete) onLoadComplete();
		};

		img.src = event.target.result;
		};

		reader.readAsDataURL(file);
		}
		} else if (mediaObject.type === 'video') {
		// å¤„ç†è§†é¢‘
		const video = document.createElement('video');
		video.src = URL.createObjectURL(file);
		video.loop = true;
		video.muted = false; // å–æ¶ˆé™éŸ³
		video.volume = 0.5; // é»˜è®¤éŸ³é‡
		video.playsInline = true;

		mediaObject.element = video;

		video.onloadedmetadata = () => {
		// æ ¹æ®è§†é¢‘æ¯”ä¾‹è°ƒæ•´å¤§å°
		const aspect = video.videoWidth / video.videoHeight;
		const height = 3.2; // 3.5ç±³é¡¶è¾¹é«˜åº¦ - 0.3ç±³è·åœ°é¢
		const width = height * aspect;

		mesh.scale.set(width, height, 1);

		// åˆ›å»ºè§†é¢‘çº¹ç†
		const texture = new THREE.VideoTexture(video);
		texture.minFilter = THREE.LinearFilter;
		texture.magFilter = THREE.LinearFilter;
		texture.format = THREE.RGBFormat;

		mediaObject.texture = texture;
		mesh.material.map = texture;
		mesh.material.needsUpdate = true;

		// æ·»åŠ æ‰©å±•åæ ‡ç­¾
		this.addExtensionLabel(mediaObject);

		// è°ƒç”¨å®Œæˆå›è°ƒ
		if (onLoadComplete) onLoadComplete();
		};

		// è§†é¢‘åŠ è½½é”™è¯¯å¤„ç†
		video.onerror = () => {
		console.error('è§†é¢‘åŠ è½½å¤±è´¥:', file.name);
		if (onLoadComplete) onLoadComplete();
		};
		}
		}

		loadGif(mediaObject, onLoadComplete) {
		const file = mediaObject.file;
		const mesh = mediaObject.mesh;

		const url = URL.createObjectURL(file);
		const img = new Image();

		img.onload = () => {
		// æ ¹æ®GIFæ¯”ä¾‹è°ƒæ•´åª’ä½“å¤§å°
		const aspect = img.width / img.height;
		const height = 3.2;
		const width = height * aspect;

		mesh.scale.set(width, height, 1);

		// ç›´æ¥åˆ›å»ºé™æ€çº¹ç†
		const texture = new THREE.Texture(img);
		texture.needsUpdate = true;

		mediaObject.texture = texture;
		mesh.material.map = texture;
		mesh.material.needsUpdate = true;

		// æ ‡è®°ä¸ºé™æ€å›¾ç‰‡ï¼Œä¸å¤„ç†æ’­æ”¾
		mediaObject.isPlaying = false;

		console.log('GIFåŠ è½½ä¸ºé™æ€å›¾ç‰‡:', file.name);

		// æ·»åŠ æ‰©å±•åæ ‡ç­¾
		this.addExtensionLabel(mediaObject);

		URL.revokeObjectURL(url);

		// è°ƒç”¨å®Œæˆå›è°ƒ
		if (onLoadComplete) onLoadComplete();
		};

		img.src = url;

		// GIFåŠ è½½é”™è¯¯å¤„ç†
		img.onerror = () => {
		console.error('GIFåŠ è½½å¤±è´¥:', file.name);
		if (onLoadComplete) onLoadComplete();
		};
		}

		addExtensionLabel(mediaObject) {
		// åˆ›å»ºæ‰©å±•åæ ‡ç­¾
		const canvas = document.createElement('canvas');
		const resolutionScale = 2; // æé«˜åˆ†è¾¨ç‡

		const text = mediaObject.extension;
		const textLength = text.length;

		canvas.width = Math.max(256, textLength * 40)* resolutionScale; // æ ¹æ®æ–‡å­—é•¿åº¦è°ƒæ•´
		canvas.height = 96 * resolutionScale;

		const context = canvas.getContext('2d');

		// ç®€çº¦èƒŒæ™¯
		context.fillStyle = 'rgba(255, 255, 255, 0.1)';
		context.fillRect(0, 0, canvas.width, canvas.height);

		// æ·»åŠ ç®€çº¦è¾¹æ¡†
		context.strokeStyle = 'rgba(255, 255, 255, 0.2)';
		context.lineWidth = 2 * resolutionScale;
		context.strokeRect(0.5, 0.5, canvas.width - 1, canvas.height - 1);

		context.font = `bold ${36 * resolutionScale}px Inter`;
		context.fillStyle = 'rgba(255, 255, 255, 0.9)';
		context.textAlign = 'center';
		context.textBaseline = 'middle';
		context.fillText(text, canvas.width / 2, canvas.height / 2);

		const texture = new THREE.CanvasTexture(canvas);
		texture.minFilter = THREE.LinearFilter;
		texture.magFilter = THREE.LinearFilter;
		texture.anisotropy = this.renderer.capabilities.getMaxAnisotropy();

		const material = new THREE.MeshBasicMaterial({
		map: texture,
		transparent: true,
		side: THREE.DoubleSide
		});

		// æ ¹æ®canvasæ¯”ä¾‹è®¡ç®—æ ‡ç­¾å¤§å°
		const labelAspect = canvas.width / canvas.height;
		const labelHeight = 0.15; // å›ºå®šé«˜åº¦
		const labelWidth = labelHeight * labelAspect; // æŒ‰æ¯”ä¾‹è®¡ç®—å®½åº¦

		const geometry = new THREE.PlaneGeometry(labelWidth, labelHeight);
		const labelMesh = new THREE.Mesh(geometry, material);

		// ä½ç½®è®¡ç®—
		labelMesh.position.y = 0.6; // åª’ä½“ä¸Šæ–¹å›ºå®šä½ç½®
		labelMesh.position.z = 0.02;

		mediaObject.mesh.add(labelMesh);
		mediaObject.labelMesh = labelMesh;
		}

		// åˆ›å»ºæ‰“èµäºŒç»´ç 
		createDonationQRCode() {
		const textureLoader = new THREE.TextureLoader();

		// åŠ è½½äºŒç»´ç å›¾ç‰‡
		textureLoader.load('./æ‰“èµäºŒç»´ç .jpg', (texture) => {
		this.createQRCodeWithTexture(texture);
		}, undefined, (error) => {
		console.error('åŠ è½½æ‰“èµäºŒç»´ç å¤±è´¥:', error);
		// å¦‚æœåŠ è½½å¤±è´¥ï¼Œåˆ›å»ºä¸€ä¸ªæ›¿ä»£çš„ç®€çº¦å¹³é¢
		this.createFallbackQRCode();
		});
		}

		// ä¿®æ”¹åçš„åˆ›å»ºå¸¦çº¹ç†çš„äºŒç»´ç 
		createQRCodeWithTexture(texture) {
		// åˆ›å»ºäºŒç»´ç å¹³é¢
		const qrGeometry = new THREE.PlaneGeometry(2, 2); // 2ç±³x2ç±³å¤§å°
		const qrMaterial = new THREE.MeshBasicMaterial({
		map: texture,
		side: THREE.FrontSide,
		transparent: true
		});

		const qrMesh = new THREE.Mesh(qrGeometry, qrMaterial);

		// ä¿®æ­£ï¼šæ”¾ç½®åœ¨å‡ºç”Ÿç‚¹èº«å2ç±³å¤„ï¼ˆZè½´ä¸ºè´Ÿå€¼ï¼‰
		qrMesh.position.set(0, 1.7, 2);

		this.scene.add(qrMesh);
		this.donationQR = qrMesh;

		// åˆ›å»ºæ–‡å­—æ ‡ç­¾æ•°ç»„
		this.donationTexts = [];

		// åˆ›å»ºä¸Šæ–¹çš„æ–‡å­—æ ‡ç­¾
		const topText = this.createFloatingText('å¦‚æœè§‰å¾—è¿˜ä¸é”™ï¼Œä¸å¦¨æ‰«æäºŒç»´ç è¯·å¼€å‘è€…å–æ¯é¥®æ–™å§ï¼',
		new THREE.Vector3(0, 1.3, 0));
		this.donationTexts.push(topText);

		// åˆ›å»ºä¸‹æ–¹çš„æ–‡å­—æ ‡ç­¾
		const bottomText = this.createFloatingText('é‚®ç®±ï¼š249390193@qq.com',
		new THREE.Vector3(0, -1.3, 0));
		this.donationTexts.push(bottomText);

		console.log('æ‰“èµäºŒç»´ç å’Œæ–‡å­—æ ‡ç­¾å·²åˆ›å»º');
		}

		// ä¿®æ”¹åçš„åˆ›å»ºçº¯æ–‡å­—æ ‡ç­¾å‡½æ•°
		createFloatingText(text, position) {
		const canvas = document.createElement('canvas');
		const context = canvas.getContext('2d');

		// è®¾ç½®å­—ä½“å’Œæµ‹é‡æ–‡å­—
		const fontSize = 60;
		context.font = `600 ${fontSize}px Inter`;
		const textMetrics = context.measureText(text);
		const textWidth = textMetrics.width;

		// è®¾ç½®canvaså°ºå¯¸ï¼ˆåŒ…å«å†…è¾¹è·ï¼‰
		const padding = 40;
		const canvasWidth = Math.ceil(textWidth + padding * 2);
		const canvasHeight = Math.ceil(fontSize * 1.5);

		canvas.width = canvasWidth;
		canvas.height = canvasHeight;

		// é‡æ–°è®¾ç½®å­—ä½“å’Œæ ·å¼
		context.font = `600 ${fontSize}px Inter`;
		context.fillStyle = 'rgba(255, 255, 255, 0.95)';
		context.textAlign = 'center';
		context.textBaseline = 'middle';

		// é€æ˜èƒŒæ™¯
		context.clearRect(0, 0, canvas.width, canvas.height);

		// ç»˜åˆ¶æ–‡å­—
		context.fillText(text, canvas.width / 2, canvas.height / 2);

		// åˆ›å»º3Dæ–‡å­—å¹³é¢
		const texture = new THREE.CanvasTexture(canvas);
		texture.minFilter = THREE.LinearFilter;
		texture.magFilter = THREE.LinearFilter;

		const material = new THREE.MeshBasicMaterial({
		map: texture,
		side: THREE.FrontSide,
		transparent: true,
		depthTest: false  // ç¦ç”¨æ·±åº¦æµ‹è¯•ï¼Œç¡®ä¿æ–‡å­—å§‹ç»ˆå¯è§
		});

		// æ ¹æ®æ–‡å­—é•¿åº¦è°ƒæ•´3Då¹³é¢å¤§å°
		const aspectRatio = canvasWidth / canvasHeight;
		const height3D = 0.3; // æ–‡å­—é«˜åº¦
		const width3D = height3D * aspectRatio;

		const geometry = new THREE.PlaneGeometry(width3D, height3D);
		const textMesh = new THREE.Mesh(geometry, material);

		// è®¾ç½®ä½ç½®ï¼ˆç›¸å¯¹äºäºŒç»´ç ï¼‰
		textMesh.position.copy(position);

		// æ·»åŠ åˆ°åœºæ™¯
		this.scene.add(textMesh);

		return textMesh;
		}

		// å¤‡ç”¨æ–¹æ¡ˆï¼šå¦‚æœäºŒç»´ç å›¾ç‰‡åŠ è½½å¤±è´¥ï¼Œåˆ›å»ºä¸€ä¸ªç®€çº¦æ›¿ä»£å“
		createFallbackQRCode() {
		// åˆ›å»ºæ›¿ä»£çº¹ç†
		const canvas = document.createElement('canvas');
		const context = canvas.getContext('2d');
		const size = 512;

		canvas.width = size;
		canvas.height = size;

		// æ·±è‰²èƒŒæ™¯
		context.fillStyle = '#1a1d2b';
		context.fillRect(0, 0, size, size);

		// ç™½è‰²è¾¹æ¡†å’Œæ–‡å­—
		context.strokeStyle = '#ffffff';
		context.lineWidth = 8;
		context.strokeRect(20, 20, size - 40, size - 40);

		context.fillStyle = '#ffffff';
		context.font = 'bold 60px Inter';
		context.textAlign = 'center';
		context.textBaseline = 'middle';
		context.fillText('äºŒç»´ç åŠ è½½å¤±è´¥', size / 2, size / 2 - 30);
		context.fillText('è¯·æ£€æŸ¥å›¾ç‰‡æ–‡ä»¶', size / 2, size / 2 + 30);

		// åˆ›å»ºçº¹ç†
		const texture = new THREE.CanvasTexture(canvas);

		// ä½¿ç”¨ç›¸åŒçš„åˆ›å»ºæ–¹æ³•
		this.createQRCodeWithTexture(texture);

		console.log('åˆ›å»ºäº†æ›¿ä»£äºŒç»´ç å¹³é¢');
		}

		playMedia(mediaObject) {
		console.log('æ’­æ”¾åª’ä½“:', mediaObject.file.name);

		if (mediaObject.type === 'video') {
		mediaObject.element.play().then(() => {
		mediaObject.isPlaying = true;
		});
		}
		}

		pauseMedia(mediaObject) {
		console.log('æš‚åœåª’ä½“:', mediaObject.file.name);

		if (mediaObject.type === 'video') {
		mediaObject.element.pause();
		mediaObject.isPlaying = false;
		}
		}

		removeAllMedia() {
		for (const mediaObject of this.mediaObjects) {
		this.unloadMedia(mediaObject);
		}

		this.mediaObjects = [];
		this.visibleMedia = [];
		this.occupiedGrids.clear();
		this.currentlyPlaying = null;
		this.hideVideoControls();

		// æ›´æ–°æ€§èƒ½ç»Ÿè®¡
		this.updatePerformanceStats();
		}

		unloadMedia(mediaObject) {
		if (mediaObject.mesh) {
		this.scene.remove(mediaObject.mesh);
		}

		if (mediaObject.element && mediaObject.type === 'video') {
		mediaObject.element.pause();
		URL.revokeObjectURL(mediaObject.element.src);
		}

		// é‡Šæ”¾çº¹ç†å†…å­˜
		if (mediaObject.texture) {
		mediaObject.texture.dispose();
		}

		// é‡Šæ”¾æ ‡ç­¾çº¹ç†
		if (mediaObject.labelMesh && mediaObject.labelMesh.material.map) {
		mediaObject.labelMesh.material.map.dispose();
		}
		}

		unloadFarthestMedia() {
		if (this.mediaObjects.length === 0) return;

		// æ‰¾åˆ°æœ€è¿œçš„åª’ä½“ï¼ˆæ’é™¤å½“å‰æ’­æ”¾çš„åª’ä½“ï¼‰
		let farthestIndex = -1;
		let maxDistance = -1;

		for (let i = 0; i < this.mediaObjects.length; i++) {
		const obj = this.mediaObjects[i];
		if (obj !== this.currentlyPlaying && obj.distance > maxDistance) {
		maxDistance = obj.distance;
		farthestIndex = i;
		}
		}

		// å¦‚æœæ‰¾åˆ°äº†æœ€è¿œçš„åª’ä½“ï¼Œå¸è½½å®ƒ
		if (farthestIndex >= 0) {
		console.log(`å¸è½½æœ€è¿œåª’ä½“: ${this.mediaObjects[farthestIndex].file.name}, è·ç¦»: ${maxDistance.toFixed(2)}ç±³`);
		this.unloadMedia(this.mediaObjects[farthestIndex]);
		this.mediaObjects.splice(farthestIndex, 1);
		}
		}

		// ä¿®æ”¹ï¼šè¯„ä¼°åª’ä½“å¯è§æ€§
		evaluateMediaVisibility() {
		const cameraPos = this.camera.position;

		// æ›´æ–°æ‰€æœ‰åª’ä½“çš„è·ç¦»
		this.mediaObjects.forEach(obj => {
		if (obj.mesh) {
		obj.distance = cameraPos.distanceTo(obj.mesh.position);
		}
		});

		// æ£€æŸ¥éœ€è¦éšè—çš„åª’ä½“
		for (let i = this.visibleMedia.length - 1; i >= 0; i--) {
		const obj = this.visibleMedia[i];

		// å¦‚æœåª’ä½“è·ç¦»è¿‡è¿œï¼ˆè¶…è¿‡70ç±³ï¼‰ï¼Œéšè—å®ƒ
		if (obj.distance > this.viewDistance) {
		this.hideMedia(obj);
		this.visibleMedia.splice(i, 1);
		}
		}

		// åŠ¨æ€ç”Ÿæˆæ–°åª’ä½“
		this.spawnMedia();
		}

		hideMedia(mediaObject) {
		if (mediaObject.mesh) {
		// ç§»å‡ºè§†é‡
		mediaObject.mesh.position.set(1000, 0, 1000);
		mediaObject.mesh.visible = false;

		// é‡Šæ”¾ç½‘æ ¼å ç”¨
		if (mediaObject.gridKey) {
		this.occupiedGrids.delete(mediaObject.gridKey);
		mediaObject.gridKey = null;
		}

		// æ ‡è®°ä¸ºä¸å¯è§
		mediaObject.isVisible = false;

		// å¦‚æœæ˜¯è§†é¢‘ä¸”æ­£åœ¨æ’­æ”¾ï¼Œæš‚åœå®ƒ
		if (mediaObject.isVideo && mediaObject.isPlaying && mediaObject !== this.currentlyPlaying) {
		this.pauseMedia(mediaObject);
		}
		}
		}

		resetPosition() {
		this.camera.position.set(0, 1.7, 0);
		this.rotation.x = 0;
		this.rotation.y = 0;
		this.camera.rotation.set(0, 0, 0);

		// é‡ç½®æ‰€æœ‰åª’ä½“çš„å¯è§æ€§
		this.visibleMedia.forEach(obj => {
		this.hideMedia(obj);
		});
		this.visibleMedia = [];
		this.occupiedGrids.clear();

		// ç¡®ä¿äºŒç»´ç ä¿æŒåœ¨èº«åä½ç½®
		if (this.donationQR) {
		this.donationQR.position.set(0, 1.7, 2);
		// é‡ç½®äºŒç»´ç æ—‹è½¬
		this.donationQR.rotation.set(0, 0, 0);
		}
		}

		// å°„çº¿æ£€æµ‹ï¼Œç”¨äºäº¤äº’
		checkIntersections() {
		const raycaster = new THREE.Raycaster();
		raycaster.setFromCamera(new THREE.Vector2(0, 0), this.camera);

		const intersects = raycaster.intersectObjects(
		this.visibleMedia
		.map(obj => obj.mesh)
		.filter(mesh => mesh && mesh.visible) // åªæ£€æŸ¥å¯è§çš„åª’ä½“
		);

		// æ¸…é™¤ä¹‹å‰çš„ç‚¹å‡»äº‹ä»¶
		this.renderer.domElement.onclick = null;
		document.body.style.cursor = 'default';

		if (intersects.length > 0) {
		const mediaObject = this.visibleMedia.find(
		obj => obj.mesh === intersects[0].object
		);

		if (mediaObject) {
		// æ£€æŸ¥æ˜¯å¦åœ¨5ç±³èŒƒå›´å†…
		const distance = this.camera.position.distanceTo(mediaObject.mesh.position);

		if (distance <= 5) {
		// å¯ä»¥äº¤äº’
		document.body.style.cursor = 'pointer';

		// ç›´æ¥ç»‘å®šç‚¹å‡»äº‹ä»¶åˆ°å½“å‰åª’ä½“å¯¹è±¡
		this.renderer.domElement.onclick = () => {
		console.log('ç‚¹å‡»åª’ä½“:', mediaObject.file.name, 'ç±»å‹:', mediaObject.type);
		this.handleMediaInteraction(mediaObject);
		};

		console.log('å¯äº¤äº’åª’ä½“:', mediaObject.file.name, 'è·ç¦»:', distance.toFixed(2));
		} else {
		console.log('åª’ä½“è·ç¦»è¿‡è¿œ:', mediaObject.file.name, 'è·ç¦»:', distance.toFixed(2));
		}
		}
		}
		}

		// ä¿®æ”¹åª’ä½“äº¤äº’å¤„ç†
		handleMediaInteraction(mediaObject) {
		console.log('å¤„ç†åª’ä½“äº¤äº’:', mediaObject.file.name);

		// å¦‚æœç‚¹å‡»çš„æ˜¯å½“å‰æ­£åœ¨æ’­æ”¾çš„åª’ä½“ï¼Œåˆ™æš‚åœ
		if (mediaObject === this.currentlyPlaying) {
		console.log('æš‚åœå½“å‰åª’ä½“');
		this.pauseMedia(mediaObject);
		this.currentlyPlaying = null;
		this.hideVideoControls();
		return;
		}

		// æš‚åœå½“å‰æ’­æ”¾çš„åª’ä½“
		if (this.currentlyPlaying) {
		console.log('æš‚åœä¹‹å‰æ’­æ”¾çš„åª’ä½“:', this.currentlyPlaying.file.name);
		this.pauseMedia(this.currentlyPlaying);
		}

		// åªæ’­æ”¾è§†é¢‘ï¼ŒGIFä½œä¸ºé™æ€å›¾ç‰‡ä¸æ’­æ”¾
		if (mediaObject.isVideo) {
		console.log('æ’­æ”¾è§†é¢‘:', mediaObject.file.name);
		this.playMedia(mediaObject);
		this.currentlyPlaying = mediaObject;
		this.showVideoControls();
		} else {
		// GIFå’Œé™æ€å›¾ç‰‡ä¸æ’­æ”¾ï¼Œåªæ ‡è®°ä¸ºå½“å‰é€‰ä¸­
		this.currentlyPlaying = mediaObject;
		this.hideVideoControls();
		console.log('é€‰ä¸­é™æ€åª’ä½“:', mediaObject.file.name);
		}
		}

		startPerformanceMonitoring() {
		// æ¯ç§’æ›´æ–°ä¸€æ¬¡æ€§èƒ½ç»Ÿè®¡
		setInterval(() => {
		this.updatePerformanceStats();
		}, 1000);
		}

		updatePerformanceStats() {
		// æ›´æ–°åª’ä½“æ•°é‡
		document.getElementById('media-count').textContent = this.mediaObjects.length;
		document.getElementById('visible-count').textContent = this.visibleMedia.length;

		// æ›´æ–°å†…å­˜ä½¿ç”¨æƒ…å†µï¼ˆä¼°ç®—ï¼‰
		let memoryUsage = 0;
		this.mediaObjects.forEach(obj => {
		if (obj.texture) {
		// ä¼°ç®—çº¹ç†å†…å­˜ä½¿ç”¨
		if (obj.isVideo) {
		memoryUsage += 10; // è§†é¢‘çº¹ç†ä¼°è®¡10MB
		} else {
		memoryUsage += 5; // å›¾ç‰‡çº¹ç†ä¼°è®¡5MB
		}
		}
		});

		document.getElementById('memory-usage').textContent = memoryUsage.toFixed(1);

		// æ›´æ–°FPS
		document.getElementById('fps-counter').textContent = this.fps;
		}

		animate() {
		requestAnimationFrame(() => this.animate());

		// æ›´æ–°ç§»åŠ¨
		this.updateMovement();

		// æ›´æ–°åª’ä½“å¯è§æ€§
		this.evaluateMediaVisibility();

		// æ›´æ–°åª’ä½“
		for (const mediaObject of this.visibleMedia) {

		// æ›´æ–°è§†é¢‘æ§åˆ¶ç•Œé¢
		if (mediaObject.type === 'video' && mediaObject.isPlaying) {
		this.updateVideoControlsUI();
		}
		}

		// æ›´æ–°æ˜Ÿç©ºæ•ˆæœ
		this.updateStarfield();

		// æ£€æŸ¥äº¤äº’
		this.checkIntersections();

		// æ›´æ–°äºŒç»´ç æ—‹è½¬ï¼Œä½¿å…¶é¢å‘ç›¸æœºï¼ˆä»…è·Ÿéšå‚ç›´æ—‹è½¬ï¼‰
		if (this.donationQR) {
		// è·å–ç›¸æœºæ—‹è½¬çš„Yåˆ†é‡ï¼ˆæ°´å¹³æ—‹è½¬ï¼‰
		const cameraYRotation = this.camera.rotation.y;

		// è®¾ç½®äºŒç»´ç çš„æ—‹è½¬ï¼Œä½¿å…¶é¢å‘ç›¸æœº
		this.donationQR.rotation.y = cameraYRotation;

		// æ›´æ–°æ–‡å­—æ ‡ç­¾çš„ä½ç½®å’Œæ—‹è½¬
		if (this.donationTexts && this.donationTexts.length > 0) {
		// è·å–äºŒç»´ç çš„ä¸–ç•Œä½ç½®
		const qrWorldPosition = new THREE.Vector3();
		this.donationQR.getWorldPosition(qrWorldPosition);

		// æ›´æ–°æ¯ä¸ªæ–‡å­—æ ‡ç­¾
		this.donationTexts.forEach((textMesh, index) => {
		if (textMesh) {
		// è®¡ç®—æ–‡å­—æ ‡ç­¾çš„ä½ç½®ï¼ˆç›¸å¯¹äºäºŒç»´ç ï¼‰
		const offsetY = index === 0 ? 1.3 : -1.3; // ä¸Šæ–¹æˆ–ä¸‹æ–¹
		const offsetZ = 0.1; // ç¨å¾®å‘å‰çªå‡º

		// è®¡ç®—æ—‹è½¬åçš„åç§»ä½ç½®
		const offset = new THREE.Vector3(0, offsetY, offsetZ);
		offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), cameraYRotation);

		// è®¾ç½®æ–‡å­—æ ‡ç­¾ä½ç½®
		textMesh.position.copy(qrWorldPosition).add(offset);

		// è®¾ç½®æ–‡å­—æ ‡ç­¾æ—‹è½¬ï¼šåªè·Ÿéšç›¸æœºçš„Yè½´æ—‹è½¬
		textMesh.rotation.set(0, cameraYRotation, 0);

		// ç¡®ä¿æ–‡å­—æ ‡ç­¾å§‹ç»ˆé¢å‘ç›¸æœºï¼ˆæ°´å¹³æ–¹å‘ï¼‰
		textMesh.lookAt(
		textMesh.position.x + Math.sin(cameraYRotation),
		textMesh.position.y,
		textMesh.position.z + Math.cos(cameraYRotation)
		);
		}
		});
		}
		}

		// æ¸²æŸ“åœºæ™¯
		this.renderer.render(this.scene, this.camera);

		// è®¡ç®—FPS
		this.frameCount++;
		const now = performance.now();
		if (now >= this.lastFpsUpdate + 1000) {
		this.fps = Math.round((this.frameCount * 1000) / (now - this.lastFpsUpdate));
		this.frameCount = 0;
		this.lastFpsUpdate = now;
		}
		}
		}

		// åˆå§‹åŒ–åº”ç”¨
		let app = null;

		window.onload = function() {
				// æ˜¾ç¤ºå¼€å±ç•Œé¢ï¼Œç­‰å¾…ç”¨æˆ·ç‚¹å‡»å¼€å§‹
				const splashScreen = document.getElementById('splash-screen');
				const startButton = document.getElementById('start-button');

				startButton.addEventListener('click', () => {
					// éšè—å¼€å±ç•Œé¢
					splashScreen.classList.add('hidden');
            
					// åˆå§‹åŒ–åº”ç”¨
					app = new VirtualMediaSpace();
				});
			};
	</script>
</body>

</html>